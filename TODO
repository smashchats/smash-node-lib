KEY USAGE ISSUE WHEN USING NODE Crypto OBJECT

## Refactoring plan

### BIG REFACTORING (with possible functional changes):

- [x] manual refactor while writing the happy path tutorial test suite (mainly splitting modules and restructuring code)
- [-] make previous test suites pass again

    - [x] tests/how-to/index.spec.ts
    - [x] tests/how-to/nbh.spec.ts
    - [ ] tests/how-to/sessions.spec.ts
    - [ ] tests/how-to/edgecases.spec.ts
    - [ ] tests/how-to/delivery.spec.ts
    - [ ] tests/how-to/identity.spec.ts

- [ ] use AI to refactor all individual code files (to be more readable, performant, maintainable, secure, efficient, etc)
- [ ] use AI to refactor module file paths structure (make sure all tests pass)
- [ ] use AI to extract more submodules: more modular, decoupled, and loosely coupled (make sure all tests pass)

### TESTS REFACTORING (keeping or increasing coverage):

- [ ] set everything private then resolve issues opening strict minimum as public APIs
- (?) use AI to generate unit .test files with mocks/spies for each module corresponding to the library API reference (**testing only publicly exported**)
- use AI to refactor functional (.spec) tests files to be more readable, maintainable, comprehensive -> corresponding to the tutorial and how to
  --> should have 100% functional coverage

test suites combined should have 100% everywhere.

### GENERATE DOCS FROM TESTS:

- convert back and forth between tests and docs (GPT API?)
- publish docs along with tests results and links to source code

use ReSpec for protocol specs repo

## Random notes

DID resolvers / generators / managers, based on

- with cache (use lib?)

https://github.com/digitalbazaar/did-io
https://www.npmjs.com/package/@digitalbazaar/did-method-key
https://www.npmjs.com/package/did-resolver
https://www.npmjs.com/package/@cef-ebsi/key-did-resolver

for badges/endorsements?:
https://www.npmjs.com/package/@cef-ebsi/verifiable-credential

https://github.com/decentralized-identity/did-resolver

## HAPPY PATH

> Refactoring from the public APIs PoV, exploring deep into the codebase
> (starting point is the public API, then refactoring the codebase to match)

Tutorial = Covers entire product but HAPPY PATH ONLY

- [x] generating a peer identity / DID
- [x] exporting a peer identity / DID
- [x] loading a peer identity into a SmashMessaging instance
- [x] connecting to SME
- [x] sending a text message to a peer
- [x] receiving a text message from a peer
- [x] handling message status updates
- [x] FEAT: ack read messages
- [x] firehose API
- [x] receiving a profile message from a peer
- [x] updating the peer's profile
- [x] clean peer shutdown
- [x] setting up a Neighborhood / NAB
- [x] joining the Neighborhood
- [x] discovering other peers in the neighborhood (NBH_PROFILE_LIST)
- [x] smashing another user from the neighborhood
- [x] passing another user from the neighborhood
- [x] clearing another user from the neighborhood

then, next feats

- [ ] loading the library with existing _data_ (tbd)
- [ ] (un)blocking another peer

### TODO

retrieve the old TODO
DIDcomm? https://identity.foundation/didcomm-messaging/spec/

\_did DNS URI record
eq to \_atproto TXT record
https://www.ietf.org/archive/id/draft-mayrhofer-did-dns-05.txt

--> write specs and get them accepted in IETF and/or W3C (referencing their own)

Note: a DID is PII as per the GDPR.

investigate JWE for the challenge
