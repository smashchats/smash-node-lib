## HAPPY PATH

- [x] generating a peer identity / DID
- [x] exporting a peer identity / DID
- [x] loading a peer identity into a SmashMessaging instance
- [x] connecting to SME
- [x] sending a text message to a peer
- [x] receiving a text message from a peer
- [x] handling message status updates
- [x] FEAT: ack read messages
- [x] firehose API
- [x] receiving a profile message from a peer
- [x] updating the peer's profile
- [x] clean peer shutdown
- [x] setting up a Neighborhood / NAB
- [x] joining the Neighborhood
- [x] discovering other peers in the neighborhood (NBH_PROFILE_LIST)
- [x] smashing another user from the neighborhood
- [x] passing another user from the neighborhood
- [x] clearing another user from the neighborhood

- [x] embedded media type
- [x] message parts & limit message queue size to keep websocket alive
- [x] emit sent and delivered status when all parts have been ack'd as such

    - [ ] Parts feedback to Client to allow them to restore queue ??? **OR RATHER**, think through the state restore & queue recovery –> half-a, half-b, full
    - [ ] add tests for concurrent messages re-assembling
    - [ ] add tests for out of order parts
    - [ ] test persistence and resilience (save/load state between restarts)

- [ ] **Investigate INITCHATS: new Date() or new Date(0)–why?? FIX DOCS.**

- [ ] loading the library with existing _data_ : convs, queues, ...

- [ ] PDS to store backup and settings (livesync multi device)

- [ ] profile updates using diff strategy & tracking current state/requesting new state?
- [ ] trust levels -> privacy
- [ ] blocking/unblocking another peer
- [ ] report peer to admins

- [ ] livestream embedded media (snap) (before sharing decryption key at last, then reconstitute) – PARTS IN PARTS??? or binary only for content???
- [ ] CDN-hosted media

- [ ] split NAB backend / frontend
- [ ] NAB persistent data

- [ ] DID standard : format and generic resolvers

    - https://medium.com/danube-tech/the-power-of-dids-5-a-deep-dive-into-service-endpoints-and-digital-product-passports-2c60f3e68f8d
    - https://github.com/w3c/did-core?tab=readme-ov-file
    - https://w3c.github.io/did-core/#dfn-service
    - https://atproto.com/specs/blob
    - https://www.ietf.org/archive/id/draft-mayrhofer-did-dns-05.txt
    - https://github.com/decentralized-identity/did-spec-extensions/blob/main/parameters/signed-ietf-json-patch.md
    - https://github.com/w3c/did-resolution/issues/7
    - https://atproto.com/specs/data-model
    - https://www.w3.org/TR/did-extensions-resolution/#signedIetfJsonPatch-param
    - https://www.w3.org/TR/did-extensions-properties/#serviceendpoint
    - https://identity.foundation/peer-did-method-spec/
    - https://learn.mattr.global/docs/cwt/dids

- [ ] DID::fetch:: key
- [ ] DID::fetch:: web
- [ ] DID re-fetch strategy on failure (re-fetch patch vs fetch replace (truth/canonical))
- [ ] DID expiry (to sync with session TTL)

- [ ] retry delays: unsent/unreceived - DID re-fetch strategy

- [ ] investigate performance and memory usage (eg, dangling sessions, dlqs, parts, no redundant compute)
- [ ] Use UTF8 vs Base64 for raw content encoding??

WARNINGS/DISCLAIMERS

[Warning] AES-CBC and AES-CTR do not provide authentication by default, and implementing it manually can result in minor, but serious mistakes. We recommended using authenticated encryption like AES-GCM to protect against chosen-ciphertext attacks. (2key-ratchet.js, line 6011)

### TESTS REFACTORING (keeping or increasing coverage):

- [ ] generate unit .test files with mocks/spies for each module corresponding to the library API reference (**testing only publicly exported**) --> should have 100% coverage for publicly exposed APIs (public and internal)
- [ ] refactor functional (.spec) tests files to be more readable, maintainable, comprehensive -> and corresponding to The Tutorial and the How-Tos --> should have 100% functional coverage (100% of the lines, combined)

### GENERATE DOCS FROM TESTS:

- [ ] convert back and forth between tests and docs (GPT API?)
- [ ] publish docs along with tests results and links to source code

use ReSpec for protocol specs repo

## Random notes

DID resolvers / generators / managers, based on

- with cache (use lib?)

https://github.com/digitalbazaar/did-io
https://www.npmjs.com/package/@digitalbazaar/did-method-key
https://www.npmjs.com/package/did-resolver
https://www.npmjs.com/package/@cef-ebsi/key-did-resolver

for badges/endorsements?:
https://www.npmjs.com/package/@cef-ebsi/verifiable-credential

https://github.com/decentralized-identity/did-resolver

DIDcomm? https://identity.foundation/didcomm-messaging/spec/

\_did DNS URI record
eq to \_atproto TXT record
https://www.ietf.org/archive/id/draft-mayrhofer-did-dns-05.txt

--> write specs and get them accepted in IETF and/or W3C (referencing their own)

Note: a DID is PII as per the GDPR.

investigate JWE for the challenge
